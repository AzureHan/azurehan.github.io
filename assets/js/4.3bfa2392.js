(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{183:function(t,e,s){"use strict";s.r(e);var i=s(0),r=Object(i.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("LRU（ Least Recently Used ）是缓存对象控制算法：最久没有访问的内容作为替换对象。相比数据库的空间，缓存的存储空间要小得多，因此缓存只能保留有限数量的缓存对象，所以需要控制缓存的数量。")]),t._v(" "),s("p",[t._v("另一个相似的替换策略：LFU（ Least Frequently Used ）很高效的算法，但很耗资源，通常不用。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),s("p",[t._v("既然是为了缓存有限数量的缓存对象，当双向链表的节点数量超过限定数量，多余的就应该从缓存中删除。「超过」的情况发生在**有新缓存对象（往双向链表插入新的节点）**的时候，这时只需要删除双向链表中最后一个节点对应的缓存数据，再把这个节点删除。")]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),s("p",[t._v("Redis 实现的 LRU 和 LFU 算法都是为了节省内存的「近似」算法。Redis 默认会随机选择 5 个 Key ，然后从中选择使用最少用的 Key 来移除。 设置 5 个是比较合适的，10 个接近实际算法但是非常消耗 CPU，3 个很快但不是非常精确。")]),t._v(" "),s("p",[t._v("实现步骤主要有：")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),s("ol",[s("li",[s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/34133067",target:"_blank",rel:"noopener noreferrer"}},[t._v("LRU原理和Redis实现——一个今日头条的面试题"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/40354122",target:"_blank",rel:"noopener noreferrer"}},[t._v("LRU Cache算法以及在redis中的应用"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://redis.io/topics/lru-cache",target:"_blank",rel:"noopener noreferrer"}},[t._v("Using Redis as an LRU cache"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://xiaorui.cc/2015/04/20/%E5%9F%BA%E4%BA%8E%E9%A2%91%E6%AC%A1%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E4%B9%8Blfu/",target:"_blank",rel:"noopener noreferrer"}},[t._v("基于最少使用频次的LFU缓存淘汰算法"),s("OutboundLink")],1)])])]),t._v(" "),t._m(8),t._v(" "),t._m(9)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"lru-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lru-算法","aria-hidden":"true"}},[this._v("#")]),this._v(" LRU 算法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_1-原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-原理","aria-hidden":"true"}},[this._v("#")]),this._v(" 1. 原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("LRU 一般由"),e("strong",[this._v("哈希表格（ Hash Table ）"),e("strong",[this._v("和")]),this._v("双向链表（ Doubly Linked List ）"),e("strong",[this._v("组成，Hash Table 负责存储应用程序的")]),this._v("缓存数据（键：值）")]),this._v("，Doubly Linked List 负责储存最近 N 个使用过的缓存数据的键。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("当使用"),e("strong",[this._v("键（存储在双向链表中的一个键）"),e("strong",[this._v("访问")]),this._v("缓存数据（存储在哈希表格中的一个值）")]),this._v("，根据「最近使用」原则，这个键应该放置在双向链表的第一个位置。双向链表第一个位置是最近第一次使用过的，这时如果访问一个是最近第三次使用过的缓存数据，LRU 需要将它应该从第三的位置插队到第一的位置。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("选择 Hash Table 是因为随机读写时间复杂度都是 O(1) ；选择 Doubly Linked List 是因为双向链表的节点保存前后节点的"),e("strong",[this._v("位置（键）")]),this._v("，如果最近访问的对象在链表中间，需要插队到第一的位置，"),e("strong",[this._v("并将它原本前后的两个节点连接在一起")]),this._v("。因为使用哈希表格，这过程中只需要三次时间复杂度为 O(1) 的读写。如果使用单链表就要遍历整个链表，队列（ Queue ）则更加不行，因为它不能直接移动中间的元素。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_2-redis-的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis-的实现","aria-hidden":"true"}},[this._v("#")]),this._v(" 2. Redis 的实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("用一个全局时钟作为参照")]),this._v(" "),e("li",[this._v("对每个 Object 初始化和操作的时候都更新它各自的 LRU 时钟")]),this._v(" "),e("li",[this._v("随机挑选几个 Key 根据 LRU 时钟计算 idle 时间排序放入 EvictionPool 中挑选 idle 时间最长的释放")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_3-参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-参考","aria-hidden":"true"}},[this._v("#")]),this._v(" 3. 参考")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"_4-todo"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-todo","aria-hidden":"true"}},[this._v("#")]),this._v(" 4. TODO")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("深入研究 Redis 的实现")]),this._v(" "),e("li",[this._v("深入研究[参考3]")])])}],!1,null,null,null);r.options.__file="LRU.md";e.default=r.exports}}]);