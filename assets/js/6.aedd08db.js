(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{181:function(e,t,r){"use strict";r.r(t);var a=r(0),i=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#树","aria-hidden":"true"}},[e._v("#")]),e._v(" 树")]),e._v(" "),r("h3",{attrs:{id:"binary-tree-二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binary-tree-二叉树","aria-hidden":"true"}},[e._v("#")]),e._v(" Binary Tree ( 二叉树 )")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("所有节点最多拥有两个子节点")])]),e._v(" "),r("li",[r("p",[e._v("左子树的键值小于根的键值，右子树的键值大于根的键值")])])]),e._v(" "),r("h3",{attrs:{id:"avl-tree-平衡二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#avl-tree-平衡二叉树","aria-hidden":"true"}},[e._v("#")]),e._v(" AVL Tree ( 平衡二叉树 )")]),e._v(" "),r("p",[e._v("基于 AVL 算法。")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("非叶子节点最多拥有两个子节点")])]),e._v(" "),r("li",[r("p",[e._v("非叶子节点的值，大于左边子节点、小于右边子节点")])]),e._v(" "),r("li",[r("p",[e._v("树的左右两边的层级数相差不会大于一")])]),e._v(" "),r("li",[r("p",[e._v("没有值相等重复的节点")])])]),e._v(" "),r("h3",{attrs:{id:"b-tree-平衡多路查找树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-平衡多路查找树","aria-hidden":"true"}},[e._v("#")]),e._v(" B-Tree ( 平衡多路查找树 )")]),e._v(" "),r("ul",[r("li",[e._v("非叶子节点拥有多个子节点，所有叶子节点均在同一层")]),e._v(" "),r("li",[e._v("叶子节点包含了 关键字、关键字数据记录的指针和 指向其子节点的指针")]),e._v(" "),r("li",[e._v("非叶子节点的关键字数量是其叶子数量少一")]),e._v(" "),r("li",[e._v("所有节点关键字是按递增次序排列，并遵循左小右大原则")])]),e._v(" "),r("h3",{attrs:{id:"b-tree-平衡多路查找树-升级版"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-平衡多路查找树-升级版","aria-hidden":"true"}},[e._v("#")]),e._v(" B+Tree ( 平衡多路查找树 - 升级版 )")]),e._v(" "),r("ul",[r("li",[e._v("非叶子节点只进行关键字索引，不会存实际的关键字数据记录的指针")]),e._v(" "),r("li",[e._v("所有数据记录的指针必须要到叶子节点才能获取到，所以每次数据查询的次数都一样")]),e._v(" "),r("li",[e._v("节点关键字数量和其子节点个数相等")])])])}],!1,null,null,null);i.options.__file="Tree.md";t.default=i.exports}}]);