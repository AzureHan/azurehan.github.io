(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{165:function(e,t,s){"use strict";s.r(t);var a=s(0),r=Object(a.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"content"},[e._m(0),e._v(" "),s("p",[e._v("Websocket 是一种在单个 TCP 连接上进行全双工通信的协议。使得客户端与服务器之间的数据交换变得更加简单，允许服务器主动向客户端推送数据。浏览器和服务器只需要完成一次握手，两者之间就可以直接创建持久性的连接，并进行双向数据传输。")]),e._v(" "),e._m(1),e._v(" "),s("p",[e._v("很多网站为了实现「推送技术」，所用的技术都是轮询。轮询是每隔一段时间，由浏览器发起 HTTP 请求，然后由服务器返回最新的数据。轮询的缺点是浏览器需要不断地向服务器发起请求，但不一定每次都有真正需要的数据，或者不能快速地得到需要的数据。")]),e._v(" "),e._m(2),e._v(" "),s("p",[e._v("URI 如下所示：")]),e._v(" "),e._m(3),e._m(4),e._v(" "),s("p",[e._v("主要与轮询（HTTP）进行对比")]),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),s("p",[e._v("Websocket 协议通过 HTTP/1.1 协议的 101 状态码进行握手从而建立连接。")]),e._v(" "),s("p",[e._v("客户端请求：")]),e._v(" "),e._m(8),s("p",[e._v("服务器响应：")]),e._v(" "),e._m(9),e._m(10),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),s("ol",[s("li",[s("a",{attrs:{href:"https://zh.wikipedia.org/wiki/WebSocket",target:"_blank",rel:"noopener noreferrer"}},[e._v("Websocket - 维基百科"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tools.ietf.org/html/rfc6455",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 6455"),s("OutboundLink")],1)])])])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"初识-websocket-协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初识-websocket-协议","aria-hidden":"true"}},[this._v("#")]),this._v(" 初识 Websocket 协议")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景","aria-hidden":"true"}},[this._v("#")]),this._v(" 背景")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在这种请况下，HTML5 定义了 Websocket 协议，能更好的节省服务器资源和宽带，并且能够更实时地进行通信。"),t("br"),this._v("Websocket 使用与 HTTP 相同的 TCP 端口，可以绕过大多数防火墙的限制。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("ws://example.com/wsapi\n\n# 运行在 TLS 上\nwss://secure.example.com/\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点","aria-hidden":"true"}},[this._v("#")]),this._v(" 优点")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("更少的控制开销")]),t("br"),this._v("在 Websocket 连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对于 HTTP 比较小。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("更强的实时性")]),t("br"),this._v("由于 Websocket 协议是全双工的，所以服务器可以随时主动给客户端下发数据，相对于 HTTP 需要「请求」+「响应」两个步骤，延迟明显更小。"),t("br"),t("br"),t("strong",[this._v("保持连接状态")]),t("br"),this._v("Websocket 是一种有状态的协议，一旦创建连接后，之后通信时可以省略部分状态信息。而 HTTP 请求可能每次都要携带如身份认证等信息。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#协议","aria-hidden":"true"}},[this._v("#")]),this._v(" 协议")])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[e._v("GET / HTTP/1.1\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Upgrade:")]),e._v(" websocket\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Connection:")]),e._v(" Upgrade\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Host:")]),e._v(" example.com\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Origin:")]),e._v(" http://example.com\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Key:")]),e._v(" sN9cRrP/n9NdMgdcy2VJFQ==\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Version:")]),e._v(" 13\n")])])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{attrs:{class:"token response-status"}},[e._v("HTTP/1.1 "),s("span",{attrs:{class:"token property"}},[e._v("101 Switching Protocols")])]),e._v("\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Upgrade:")]),e._v(" websocket\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Connection:")]),e._v(" Upgrade\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Accept:")]),e._v(" fFBooB7FAkLlXgRSz0BT3v4hq5s=\n"),s("span",{attrs:{class:"token header-name keyword"}},[e._v("Sec-WebSocket-Location:")]),e._v(" ws://example.com/\n")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("strong",[this._v("字段说明")])])},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ul",[s("li",[e._v("Connection ：必须设置为 Upgrade ，表示客户端希望连接升级。")]),e._v(" "),s("li",[e._v("Upgrade ：必须设置为 Websocket ，表示希望升级到 Websocket 协议。")]),e._v(" "),s("li",[e._v("Sec-WebSocket-Key ：随机的字符串。确保服务器不接受来自非 WebSocket 客户端的连接（例如 HTTP），客户端被滥用来向不知情的 WebSocket 发送数据。")]),e._v(" "),s("li",[e._v("Sec-WebSocket-Accept ：确认服务器是否愿意启动 WebSocket 连接。服务器端将 "),s("code",[e._v("Sec-WebSocket-Key")]),e._v(" 加上一个特殊字符串计算 SHA-1 摘要进行 BASE-64 编码。")]),e._v(" "),s("li",[e._v("Sec-WebSocket-Version ：表示支持的 Websocket 版本。")]),e._v(" "),s("li",[e._v("Origin ：通常用来表示在浏览器中发起此 Websocket 连接所在的页面，只包含了协议和主机名称。")]),e._v(" "),s("li",[e._v("其他一些定义在 HTTP 协议中的字段，如 Cookie 等，也可以在 Websocket 中使用。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[this._v("#")]),this._v(" 参考资料")])}],!1,null,null,null);r.options.__file="Websocket-first-face.md";t.default=r.exports}}]);