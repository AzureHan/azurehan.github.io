(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{192:function(a,t,_){"use strict";_.r(t);var v=_(0),r=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"高性能-mysql-第三版-笔记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#高性能-mysql-第三版-笔记","aria-hidden":"true"}},[a._v("#")]),a._v(" 高性能 MySQL ( 第三版 ) 笔记")]),a._v(" "),_("h2",{attrs:{id:"第一章：架构与历史"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一章：架构与历史","aria-hidden":"true"}},[a._v("#")]),a._v(" 第一章：架构与历史")]),a._v(" "),_("h3",{attrs:{id:"并发控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发控制","aria-hidden":"true"}},[a._v("#")]),a._v(" 并发控制")]),a._v(" "),_("h4",{attrs:{id:"读写锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 读写锁")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"锁粒度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#锁粒度","aria-hidden":"true"}},[a._v("#")]),a._v(" 锁粒度")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"表锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#表锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 表锁")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"行级锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行级锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 行级锁")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h3",{attrs:{id:"事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务","aria-hidden":"true"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),_("p",[a._v("事务的 ACID 是一些标准特征，表示一个运行良好的事务处理系统。")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("Atomicity ( 原子性 ) : 一个事务必须被视为一个不可分割的最小工作单元")])]),a._v(" "),_("li",[_("p",[a._v("Consistency ( 一致性 ) : 数据库总是从一个一致性的状态转换到另一个一致性的状态")])]),a._v(" "),_("li",[_("p",[a._v("Isolation ( 隔离性 ) : 通常来说，一个事务所做的修改在最终提交前，对其他事务是不可见的")])]),a._v(" "),_("li",[_("p",[a._v("Durability ( 持久性 ) : 一旦事务提交所做的修改就会永久保存到数据库中 ( 即使系统崩溃 )")])])]),a._v(" "),_("h4",{attrs:{id:"隔离级别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别","aria-hidden":"true"}},[a._v("#")]),a._v(" 隔离级别")]),a._v(" "),_("p",[a._v("隔离是指在进行中的两个事务间，提供给事务使用的数据应根据哪个属于它的时空，而 MySQL 的隔离级别设定是“可重复读”。")]),a._v(" "),_("p",[a._v("隔离级别有四种：")]),a._v(" "),_("ul",[_("li",[a._v("Read uncommit ( 未提交读 ) : 即使事务的修改没有提交其他事务也能看见")]),a._v(" "),_("li",[a._v("Read commited ( 提交读 ) : 一个事务从开始到提交前的所有更改都对其他事务不可见")]),a._v(" "),_("li",[a._v("Repeatable read ( 可重复读 ) : 同一个事务 ( 无论其他事务如何 ) 多次读取同样的记录结果都是一致的")]),a._v(" "),_("li",[a._v("Serializable ( 可串行化 ) : 通过强制事务串行执行实现最高的隔离级别")])]),a._v(" "),_("blockquote",[_("p",[a._v("所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当前的事务再次读取该范围的记录时会产生幻行。理论上可重复度无法解决这个问题，InnoDB 和 XtraDB 存储引擎通过多 MVCC ( 版本并发控制 ) 解决了幻读问题。 "),_("em",[a._v("[ 不考虑并发是不是还有一个叫间隙锁的东西与幻读相关 ？ ]")])])]),a._v(" "),_("h4",{attrs:{id:"死锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"事务日志"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 事务日志")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"mysql-中的事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql-中的事务","aria-hidden":"true"}},[a._v("#")]),a._v(" MySQL 中的事务")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h3",{attrs:{id:"多版本并发控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多版本并发控制","aria-hidden":"true"}},[a._v("#")]),a._v(" 多版本并发控制")]),a._v(" "),_("h3",{attrs:{id:"mysql-引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql-引擎","aria-hidden":"true"}},[a._v("#")]),a._v(" MySQL 引擎")]),a._v(" "),_("h2",{attrs:{id:"第二章：基准测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二章：基准测试","aria-hidden":"true"}},[a._v("#")]),a._v(" 第二章：基准测试")]),a._v(" "),_("h3",{attrs:{id:"基准测试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基准测试","aria-hidden":"true"}},[a._v("#")]),a._v(" 基准测试")]),a._v(" "),_("p",[a._v("基准测试工具有 http_load 和 sysbanch ： http_load 主要功能是以最快速度循环请求一组自定义的 URL 列表，并且有并发、频率、时间的参数控制测试 ; sysbanch 主要功能是")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h2",{attrs:{id:"第三章：服务器性能剖析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三章：服务器性能剖析","aria-hidden":"true"}},[a._v("#")]),a._v(" 第三章：服务器性能剖析")]),a._v(" "),_("h3",{attrs:{id:"剖析-mysql-查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#剖析-mysql-查询","aria-hidden":"true"}},[a._v("#")]),a._v(" 剖析 MySQL 查询")]),a._v(" "),_("p",[a._v("慢查询日志是开销最低、精度最高的测量查询时间的工具。IO 资源开销比 CPU 资源开销小得多，但要注意磁盘空间的消耗，长期开启需要部署日志轮转 ( log rotation ) 工具。从慢查询日志生成剖析报告可以使用 pt-query-digest 工具。")]),a._v(" "),_("p",[a._v("剖析查询可以使用 SHOW PROFILE 、 SHOW STATUS 和 EXPLAIN 命令。SHOW PROFILE 可以得到完成查询所有步骤的耗时，结果是高精度的，不像平时查询最后的那个耗时只有精确到小数点后两位。SHOW STATUS 可以得到服务器或单个连接会话中执行过的查询的各种计数器，用实际测量结果来分析查询语句。EXPLAIN 可以得到查询语句的执行计划，不同于 SHOW STATUS ， EXPLAIN 只能是估计查询结果，但仍然有助于分析查询语句。")]),a._v(" "),_("h3",{attrs:{id:"诊断间歇性问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#诊断间歇性问题","aria-hidden":"true"}},[a._v("#")]),a._v(" 诊断间歇性问题")]),a._v(" "),_("p",[a._v("假定服务器整体运行没有问题，只有某条查询偶尔变慢，就需要将注意力放到这条特定的查询上面。")]),a._v(" "),_("p",[a._v("使用 SHOW GLOBAL STATUS 命令以每秒的频率捕获数据，问题出现时，则可以通过某些计数器的“尖刺”或者“凹陷”来发现问题。这种方法成本较低，不失为一个值得花时间学习去解决问题的好方法。")]),a._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{attrs:{class:"token comment"}},[a._v("# 示例命令 [ 不明白 ]")]),a._v("\n$ mysqladmin ext -i1 "),_("span",{attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),_("span",{attrs:{class:"token function"}},[a._v("awk")]),a._v(" ‘ 这里忽略 ’\n")])])]),_("p",[a._v("AWK 是一种优良地文本处理工具，提供了极其强大地功能：可以进行正则表达式地匹配、样式装入、流控制、进程控制语句甚至于内置地变量和函数。\n使用 SHOW PROCESSLIST 通过不断地获取输出，来观察是否有大量线程处于不正常或者有其他不正常地特征。如果要查看不同地列，只需要修改 grep 地模式即可。")]),a._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{attrs:{class:"token comment"}},[a._v("# 示例命令")]),a._v("\n$ mysql -e ‘SHOW PROCESSSLIST\\G’ "),_("span",{attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),_("span",{attrs:{class:"token function"}},[a._v("grep")]),a._v(" State: "),_("span",{attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),_("span",{attrs:{class:"token function"}},[a._v("sort")]),a._v(" "),_("span",{attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),_("span",{attrs:{class:"token function"}},[a._v("uniq")]),a._v(" -c "),_("span",{attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),_("span",{attrs:{class:"token function"}},[a._v("sort")]),a._v(" -rn\n")])])]),_("p",[a._v("使用慢查询 ( long query ) 日志针对需要通过查询日志发现的问题，设置 long_query_time 为 0 捕获所有查询。观察吞吐量找到异常的时间段，再具体分析其中的查询。加之该时间段前也有可能是导致问题的导火索，也许是因为阻塞了之后的查询。")]),a._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{attrs:{class:"token comment"}},[a._v("# 示例命令")]),a._v("\n$ "),_("span",{attrs:{class:"token function"}},[a._v("awk")]),a._v(" "),_("span",{attrs:{class:"token string"}},[a._v("'/^# Time:/{print "),_("span",{attrs:{class:"token variable"}},[a._v("$3")]),a._v(", "),_("span",{attrs:{class:"token variable"}},[a._v("$4")]),a._v(", c;c=0}/^# User/{c++}'")]),a._v(" slow-query.log\n")])])]),_("p",[a._v("再重申一次：比如以上的好的工具可以帮助诊断这类问题，否则要人工去几百 GB 的查询日志中找原因。再有绘图工具对观察也有很大帮助，比如使用 gnuplot 或 R 。")]),a._v(" "),_("h3",{attrs:{id:"捕获诊断数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#捕获诊断数据","aria-hidden":"true"}},[a._v("#")]),a._v(" 捕获诊断数据")]),a._v(" "),_("p",[a._v("触发器非常重要，这是在问题出现时能够捕获数据的基础。当一些比较敏感的计数器数值在一段时间都出现异常数值，就可以开始捕获数据。")]),a._v(" "),_("p",[a._v("举个例子，Threads_connected 偶尔出现非常高的尖峰，如果在正常时该值一般不超过 150，那将触发器的阈值设置为 300 会更好，而不是设置成和在尖峰时相当的数值，那样捕获数据就迟了。")]),a._v(" "),_("p",[a._v("在问题还是涓涓细流的时候就要开始收集数据，而不要等到波涛汹涌才开始。但同时也要避免误报，短暂的尖峰其实可能并没有问题，那可以加上持续时间的判断。例如当数值持续超过 5 秒都超过了阈值，那就开始收集诊断数据。而现有工具 Percona Toolkit 中的 ps-stalk 就是为这种情况设计的。")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h2",{attrs:{id:"第四章：scheme-与数据类型优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四章：scheme-与数据类型优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 第四章：Scheme 与数据类型优化")]),a._v(" "),_("p",[a._v("良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计 Schema，这往往需要权衡各种因素。例如，反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，但这些表的维护成本可能会很高。MySQL独有的特性和实现细节对性能的影响也很大。")]),a._v(" "),_("h3",{attrs:{id:"_4-1-选择数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-选择数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1 选择数据类型")]),a._v(" "),_("p",[_("strong",[a._v("数据类型的一些简单的选择原则")]),a._v(" :")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("更小的通常更好")]),a._v(" "),_("p",[a._v("更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。")])]),a._v(" "),_("li",[_("p",[a._v("简单就好")]),a._v(" "),_("p",[a._v("简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校对规则 ( 排序规则 ) 使字符比较比整型比较更复杂。")])]),a._v(" "),_("li",[_("p",[a._v("选择符合储存的最小要求")]),a._v(" "),_("p",[a._v("这里有两个例子 : 一个是应该使用 MySQL 内建的类型而不是字符串来存储日期和时间，另外一个是应该用整型存储 IPv4 地址。")])]),a._v(" "),_("li",[_("p",[a._v("尽量避免 NULL 值字段")]),a._v(" "),_("p",[a._v("MySQL 难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要 MySQL 内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致 MyISAM 中固定大小的索引变成可变大小的索引。SQL 的 "),_("code",[a._v("NOT IN ()")]),a._v(" 或 "),_("code",[a._v("!=")]),a._v("  中 包含 NULL 还会使结果集返回空。")])])]),a._v(" "),_("h4",{attrs:{id:"_4-1-1-整数类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-1-整数类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1.1 整数类型")]),a._v(" "),_("p",[a._v("整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用 8，16，24，32，64 位存储空间。它们可以存储的值的范围从 2(N−1) 到 2(N−1)−1 。MySQL可以为整数类型指定宽度，例如 "),_("code",[a._v("INT(11)")]),a._v(" ，对大多数应用这是没有意义，它不会实际限制值的合法范围。")]),a._v(" "),_("h4",{attrs:{id:"_4-1-2-实数类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-2-实数类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1.2 实数类型")]),a._v(" "),_("p",[a._v("实数是带有小数部分的数字。然而，它们不只是为了存储小数部分 ; 也可以使用 DECIMAL 存储比 BIGINT 还大的整数。MySQL 既支持精确类型，也支持不精确类型。")]),a._v(" "),_("p",[a._v("FLOAT 和 DOUBLE 类型存储浮点小数，分别使用 4 和 8 字节存储，支持使用浮点运算 ; DECIMAL 类型存储精确小数，最多 65 个数字，支持使用精确运算 。CPU 不支持对 DECIMAL 的直接计算，MySQL 服务器自身实现了 DECIMAL 的高精度计算。相对而言，CPU 直接支持原生浮点计算，所以浮点运算明显更快。")]),a._v(" "),_("p",[a._v("MySQL 将数字打包保存到一个二进制字符串中 "),_("em",[a._v("( 每 4 个字节存 9 个数字 )")]),a._v(" 。例如 "),_("code",[a._v("DECIMAL(18,9)")]),a._v(" 小数点两边将各存储 9 个数字，一共使用 9 个字节 : 小数点前的数字用 4 个字节，小数点后的数字用 4 个字节，小数点本身占 1 个字节。")]),a._v(" "),_("h4",{attrs:{id:"_4-1-3-字符串类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-3-字符串类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1.3 字符串类型")]),a._v(" "),_("p",[a._v("VARCHAR 和 CHAR 是两种最主要的字符串类型。而值是怎么存储在磁盘和内存中的，这很难精确地解释，因为这跟存储引擎的具体实现有关，一般就 InnoDB 或 MyISAM 引擎而论。")]),a._v(" "),_("p",[a._v("更长的列会消耗更多的内存，因为 MySQL 通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。")]),a._v(" "),_("h5",{attrs:{id:"varchar"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#varchar","aria-hidden":"true"}},[a._v("#")]),a._v(" VARCHAR")]),a._v(" "),_("p",[a._v("用于存储可变长字符串，比定长类型 CHAR 更节省空间，需要使用额外字节记录字符串的长度 : 如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节。")]),a._v(" "),_("p",[a._v("虽然节省存储空间，对性能有帮助。但如果在 UPDATE 时使行变得比原来更长，并且在页内没有更多的空间可以存储，这种情况不同的存储引擎的处理方式是不一样的。MyISAM 会将行拆成不同的片段存储，InnoDB 则需要分裂页来使行可以放进页内，其他一些存储引擎也许从不在原数据位置更新数据。")]),a._v(" "),_("p",[a._v("下面这些情况下使用 VARCHAR 是合适的 : 字符串列的最大长度比平均长度大很多 ; "),_("strong",[a._v("列的更新很少，所以碎片不是问题")]),a._v(" ; "),_("strong",[a._v("使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储")]),a._v(" 。")]),a._v(" "),_("h5",{attrs:{id:"char"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#char","aria-hidden":"true"}},[a._v("#")]),a._v(" CHAR")]),a._v(" "),_("p",[a._v("适合存储很短的字符串，或者所有值都接近同一个长度，例如密码的哈希值。对于经常变更的数据，CHAR 比 VARCHAR 更好，因为定长的 CHAR 类型不容易产生碎片。")]),a._v(" "),_("h5",{attrs:{id:"blob-和-text"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#blob-和-text","aria-hidden":"true"}},[a._v("#")]),a._v(" BLOB 和 TEXT")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h5",{attrs:{id:"enum"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#enum","aria-hidden":"true"}},[a._v("#")]),a._v(" ENUM")]),a._v(" "),_("p",[a._v("字符串列表是固定的，添加或删除字符串必须使用 ALTER TABLE，除非只在列表最后追加元素，否则不是一个好的字段类型选择。可以用于 JOIN 关联表的 VARCHAR 字段，但会影响性能，如果是相同类型之间的 JOIN 关联就没有影响。")]),a._v(" "),_("h4",{attrs:{id:"_4-1-4-日期和时间类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-4-日期和时间类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1.4 日期和时间类型")]),a._v(" "),_("p",[a._v("大部分时间类型都没有替代品，因此没有什么是最佳选择的问题。MySQL 能存储的最小时间粒度为秒，MariaDB 支持微秒级别的时间类型。")]),a._v(" "),_("h5",{attrs:{id:"datetime"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#datetime","aria-hidden":"true"}},[a._v("#")]),a._v(" DATETIME")]),a._v(" "),_("p",[a._v("从 1001 年到 9999 年，精度为秒。格式为 "),_("code",[a._v("YYYYMMDDHHMMSS")]),a._v(" 的整数，与时区无关。使用 8 个字节的存储空间。")]),a._v(" "),_("h5",{attrs:{id:"timestamp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#timestamp","aria-hidden":"true"}},[a._v("#")]),a._v(" TIMESTAMP")]),a._v(" "),_("p",[a._v("从1970年1月1日午夜 ( 格林尼治标准时间 ) 以来的秒数，最多到 2038 年。它和 UNIX 时间戳相同，与时区有关，MySQL服务器、操作系统，以及客户端连接都有时区设置。使用 4 个字节的存储空间。")]),a._v(" "),_("h4",{attrs:{id:"_4-1-5-位数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-5-位数据类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1.5 位数据类型")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"_4-1-6-选择标识符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-6-选择标识符","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.1.6 选择标识符")]),a._v(" "),_("p",[a._v("整数通常是标识列最好的选择 ; EMUM 和 SET 类型通常是一个糟糕的选择 ; 避免使用字符串类型作为标识列 。")]),a._v(" "),_("p",[a._v("一旦选定了一种类型，要确保在所有关联表中都使用同样的类型。类型之间需要精确匹配，包括像 UNSIGNED 这样的属性。")]),a._v(" "),_("h3",{attrs:{id:"_4-2-schema-设计中的陷阱"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-schema-设计中的陷阱","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.2 Schema 设计中的陷阱")]),a._v(" "),_("h5",{attrs:{id:"太多的列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#太多的列","aria-hidden":"true"}},[a._v("#")]),a._v(" 太多的列")]),a._v(" "),_("p",[a._v("MySQL 的存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。")]),a._v(" "),_("h5",{attrs:{id:"太多的关联"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#太多的关联","aria-hidden":"true"}},[a._v("#")]),a._v(" 太多的关联")]),a._v(" "),_("p",[a._v("每个关联操作最多只能有 61 张表，单个查询最好在 12 个表以内做关联。所谓的 EAV ( 实体 - 属性 - 值 ) 设计模式是糟糕的，它需要许多自关联。")]),a._v(" "),_("h5",{attrs:{id:"全能的枚举"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#全能的枚举","aria-hidden":"true"}},[a._v("#")]),a._v(" 全能的枚举")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h5",{attrs:{id:"变相的枚举"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变相的枚举","aria-hidden":"true"}},[a._v("#")]),a._v(" 变相的枚举")]),a._v(" "),_("p",[a._v("枚举 ( ENUM ) 列允许在列中存储一组定义值中的单个值，集合 ( SET ) 列则允许在列中存储一组定义值中的一个或多个值，有时候这可能比较容易导致混乱。")]),a._v(" "),_("h5",{attrs:{id:"非此发明-not-invent-here-的-null"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非此发明-not-invent-here-的-null","aria-hidden":"true"}},[a._v("#")]),a._v(" 非此发明 (Not Invent Here ) 的 NULL")]),a._v(" "),_("p",[a._v("NULL 也许可以使用 0 、空字符串、或者某个特殊值代替，但也不要走极端。当确实需要表示未知值时也不要害怕使用 NULL ，不然这个特殊值可能会产生歧义。")]),a._v(" "),_("h3",{attrs:{id:"_4-3-范式和反范式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-范式和反范式","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.3 范式和反范式")]),a._v(" "),_("p",[a._v("对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。")]),a._v(" "),_("h4",{attrs:{id:"_4-3-1-范式的优点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-1-范式的优点和缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.3.1 范式的优点和缺点")]),a._v(" "),_("p",[a._v("当为性能问题而寻求帮助时，经常会被建议对 Schema 进行范式化设计，尤其是写密集的场景。")]),a._v(" "),_("p",[a._v("优点 :")]),a._v(" "),_("ul",[_("li",[a._v("更新操作更快")]),a._v(" "),_("li",[a._v("不需要重复更改多处")]),a._v(" "),_("li",[a._v("更精简的表能放入内存操作")]),a._v(" "),_("li",[a._v("检索数据没有多余的数据")])]),a._v(" "),_("p",[a._v("缺点 :")]),a._v(" "),_("ul",[_("li",[a._v("是通常需要为简单的需求关联复杂关系的表")]),a._v(" "),_("li",[_("strong",[a._v("可能使一些索引策略失效")])])]),a._v(" "),_("h4",{attrs:{id:"_4-3-2-反范式的优点和缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-2-反范式的优点和缺点","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.3.2 反范式的优点和缺点")]),a._v(" "),_("p",[a._v("反范式避免关联，即使没有索引进而全表扫描，也可能比关联要快，因为避免了随机 IO 。也就是说，如果冗余的字段上有索引，效率就更高了。")]),a._v(" "),_("h4",{attrs:{id:"_4-3-3-混用范式化和反范式化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-3-混用范式化和反范式化","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.3.3 混用范式化和反范式化")]),a._v(" "),_("p",[a._v("事实是，完全的范式化和完全的反范式化 Schema 都是实验室里才有的东西，在真实世界中很少会这么极端地使用。在实际应用中经常需要混用，可能使用部分范式化的 Schema、缓存表，以及其他技巧。")]),a._v(" "),_("h3",{attrs:{id:"_4-4-缓存表和汇总表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-缓存表和汇总表","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.4 缓存表和汇总表")]),a._v(" "),_("p",[a._v("有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表 ( 特别是为满足检索的需求时 ) 。缓存表 : 可以从简单结构的表中获取关键数据 ; 汇总表 : 将一段时间的数据的计数聚集以提供检索 。可以实时维护或者定期重建这些数据表，重建可以通过使用『 影子表 』来实现高可用重建。")]),a._v(" "),_("h4",{attrs:{id:"_4-4-1-物化视图"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-物化视图","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.4.1 物化视图")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"_4-4-2-计数器表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-计数器表","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.4.2 计数器表")]),a._v(" "),_("p",[a._v("如果汇总某项计数，在表使用一行来记录，当面对高并发场景，则会造成阻塞。解决方案是分表分行 : 汇总数据按一段日期划分成相应的数据表，可以减小但表的大小 ; 一项计数由原本存储在一行改为存储在多行中，可以减少锁的争用 。")]),a._v(" "),_("h3",{attrs:{id:"_4-5-加快-alter-table-操作的速度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-加快-alter-table-操作的速度","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.5 加快 ALTER TABLE 操作的速度")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"_4-5-1-只修改-xxx-frm-文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-1-只修改-xxx-frm-文件","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.5.1 只修改 xxx.frm 文件")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"_4-5-2-快速创建-myisam-索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-2-快速创建-myisam-索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.5.2 快速创建 MyISAM 索引")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h3",{attrs:{id:"_4-6-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 4.6 总结")]),a._v(" "),_("ul",[_("li",[a._v("尽量避免过度设计，例如会导致极其复杂查询的 Schema 设计，或者有很多列的表设计")]),a._v(" "),_("li",[a._v("使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用 NULL 值")]),a._v(" "),_("li",[a._v("尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列")]),a._v(" "),_("li",[a._v("注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存")]),a._v(" "),_("li",[a._v("尽量使用整型定义标识列")]),a._v(" "),_("li",[a._v("避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度")]),a._v(" "),_("li",[a._v("小心使用 ENUM 和 SET ，虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱")]),a._v(" "),_("li",[a._v("最好避免使用 BIT")]),a._v(" "),_("li",[a._v("综合情况使用范式和反范式设计")])]),a._v(" "),_("h2",{attrs:{id:"第五章：创建高性能的索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第五章：创建高性能的索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 第五章：创建高性能的索引")]),a._v(" "),_("p",[a._v("索引、在 MySQL 中也叫做『 键 ( key ) 』，是存储引擎用于快速找到记录的一种数据结构。建立正确的索引可能比优化查询还要重要，索引也许可以更好，也有可能更差。")]),a._v(" "),_("h3",{attrs:{id:"_5-1-索引基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-索引基础","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1 索引基础")]),a._v(" "),_("p",[a._v("在 MySQL 中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。")]),a._v(" "),_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[a._v("mysql"),_("span",{attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),_("span",{attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" first_name "),_("span",{attrs:{class:"token keyword"}},[a._v("FROM")]),a._v(" sakila"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("actor "),_("span",{attrs:{class:"token keyword"}},[a._v("WHERE")]),a._v(" actor_id"),_("span",{attrs:{class:"token operator"}},[a._v("=")]),_("span",{attrs:{class:"token number"}},[a._v("5")]),_("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),_("p",[a._v("如果在 "),_("code",[a._v("actor_id")]),a._v(" 列上建有索引，则 MySQL 将使用该索引找到 "),_("code",[a._v("actor_id=5")]),a._v(" 的行，也就是说，MySQL 先在索引上按值进行查找，然后返回所有包含该值的数据行。")]),a._v(" "),_("p",[a._v("索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。")]),a._v(" "),_("blockquote",[_("p",[a._v("ORM ( 对象关系映射 ) 工具能够生产符合逻辑的、合法的查询 ( 多数时候 ) ，除非只是生成非常基本的查询 ( 例如仅是根据主键查询 ) ，否则它很难生成适合索引的查询。很多时候，即使是查询优化技术专家也很难兼顾到各种情况，更别说 ORM 了。")])]),a._v(" "),_("h4",{attrs:{id:"_5-1-1-索引的类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-索引的类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1.1 索引的类型")]),a._v(" "),_("p",[a._v("在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准 : 不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。")]),a._v(" "),_("h5",{attrs:{id:"_5-1-1-1-b-tree-索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-1-b-tree-索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1.1.1 B-Tree 索引")]),a._v(" "),_("p",[a._v("当人们谈论索引的时候，如果没有特别指明类型，那多半说的是 B-Tree 索引。它使用 B-Tree 数据结构来存储数据，通常意味着所有的值都是按 "),_("strong",[a._v("顺序")]),a._v(" 存储的，因此查找范围数据的查询效率更高。同样，查询时字段组成索引也需要按定义索引的顺序。当数据可以通过 B-Tree 索引关键字来查找，就可以不进行全表扫描，从而更快访问对应的数据。另外，索引也可以用于 ORDER BY 子句中。")]),a._v(" "),_("p",[a._v("B-Tree 索引 有效的 匹配类型 :")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("全值匹配")])]),a._v(" "),_("li",[_("p",[a._v("匹配最左前缀")])]),a._v(" "),_("li",[_("p",[a._v("匹配列前缀")])]),a._v(" "),_("li",[_("p",[a._v("匹配范围值")])]),a._v(" "),_("li",[_("p",[a._v("精确匹配某一列并范围匹配另一列")])]),a._v(" "),_("li",[_("p",[a._v("只访问索引的查询")])])]),a._v(" "),_("p",[a._v("B-Tree 索引 无效的 匹配类型 :")]),a._v(" "),_("ul",[_("li",[a._v("不按照索引的最左列开始查找")]),a._v(" "),_("li",[a._v("跳过索引中间的列")]),a._v(" "),_("li",[a._v("如果索引中某列应用范围查询 ( 剩余的列就无效 )")])]),a._v(" "),_("h5",{attrs:{id:"_5-1-1-2-哈希索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-2-哈希索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1.1.2 哈希索引")]),a._v(" "),_("p",[a._v("只对精确匹配索引所有列的查询才有效。存储引擎都会对所有的索引列 ( 根据键值 ) 计算一个值较小的哈希码 ( hash code ) 。哈希码存储在索引中，哈希表中保存指向每个数据行的指针。")]),a._v(" "),_("p",[a._v("Memory 引擎的默认索引类型是哈希索引 ( 也支持 B-Tree ) ，与众不同的是也支持非唯哈希一索引，相同哈希值以链表的方式存放到一个哈希条目中。")]),a._v(" "),_("p",[a._v("数据结构由 槽 ( Slot ) 和 值 ( Value ) 组成，其中槽的编号是按顺序的。因为索引结构十分紧凑，所以查找速度非常快。 "),_("em",[_("strong",[a._v("如果是非唯一哈希索引，值应该是链表？")])]),a._v(" 当有哈希冲突 ( 不同的索引列值却有相同的哈希值 ) ，储引擎必须遍历链表中所有的行比较，直到找到所有符合条件的行。较多的冲突会影响查找性能，也提高维护操作的代价。")]),a._v(" "),_("p",[a._v("哈希索引的限制 :")]),a._v(" "),_("ul",[_("li",[a._v("内存中读取行除外，不能利用索引中的值来避免读取行来提高性能")]),a._v(" "),_("li",[a._v("索引数据不按照索引值顺序存储，无法用于排序查询")]),a._v(" "),_("li",[a._v("较多的哈希冲突会影响性能")]),a._v(" "),_("li",[a._v("不支持部分索引列匹配查找")]),a._v(" "),_("li",[a._v("只支持等值比较查询 ( "),_("code",[a._v("=")]),a._v(" 、"),_("code",[a._v("IN()")]),a._v(" 、"),_("code",[a._v("<=>")]),a._v(" ) ，不支持任何范围查询")])]),a._v(" "),_("p",[a._v("InnoDB 引擎有个特殊的功能 『 自适应哈希索引 』，当某些索引值使用频繁，它会存在内存中基于 B-Tree 之上的哈希索引中。此内部的功能完全自动，无需用户干预但可以关闭。")]),a._v(" "),_("p",[a._v("在数据仓库应用中有一种经典的『 星型 』schema ，需要关联很多查找表，哈希索引就非常适合查找表的需求。在不支持哈希索引的存储引擎中，如果存储数据具备哈希索引的应用场景 ( 例如 URL 数据 ) ，用户可以自行实现哈希索引。")]),a._v(" "),_("p",[_("code",[a._v("https://a2ure.com")]),a._v(" 的哈希值 :")]),a._v(" "),_("table",[_("thead",[_("tr",[_("th",[a._v("算法")]),a._v(" "),_("th",[a._v("哈希值")]),a._v(" "),_("th",[a._v("长度")])])]),a._v(" "),_("tbody",[_("tr",[_("td",[a._v("MD5")]),a._v(" "),_("td",[a._v("6A8EC5631CDF5A06BE91C2CEA0DE1F7B")]),a._v(" "),_("td",[a._v("32 ( 128 位 )")])]),a._v(" "),_("tr",[_("td",[a._v("SHA1")]),a._v(" "),_("td",[a._v("4A5ADE2BFD6C5819AEC5895E19433D9440BD60F6")]),a._v(" "),_("td",[a._v("40 ( 160 位 )")])]),a._v(" "),_("tr",[_("td",[a._v("CRC32")]),a._v(" "),_("td",[a._v("9D093C3C")]),a._v(" "),_("td",[a._v("8 ( 32 位 )")])]),a._v(" "),_("tr",[_("td",[a._v("FNV164")]),a._v(" "),_("td",[a._v("F06D9CAFB931D940")]),a._v(" "),_("td",[a._v("16 ( 64 位 )")])])])]),a._v(" "),_("p",[a._v("算法函数 SHA1 和 MD5 速度慢而且长度长可能不适合作为哈希函数 ; 算法 CRC32 长度短可能会因为『 生日悖论 』出现哈希冲突徒增。")]),a._v(" "),_("h5",{attrs:{id:"_5-1-1-3-空间数据索引-r-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-3-空间数据索引-r-tree","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1.1.3 空间数据索引 ( R-Tree )")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h5",{attrs:{id:"_5-1-1-4-全文索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-4-全文索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1.1.4 全文索引")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h5",{attrs:{id:"_5-1-1-5-其他索引类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-5-其他索引类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.1.1.5 其他索引类型")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h3",{attrs:{id:"_5-2-索引的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-索引的优点","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.2 索引的优点")]),a._v(" "),_("p",[a._v("常用的 B-Tree 索引不仅可以用于快速读取行，因为数据按顺序存储，也可用于 ORDER BY 和 GROUP BY 。三星系统 ( three-star system ) ，衡量索引是否适合某个查询。索引将相关的记录放到一起则获得一星 ; 索引中的数据顺序和查找中的排列顺序一致则获得二星 ; 索引中的列包含了查询中需要的全部列则获得三星。")]),a._v(" "),_("ul",[_("li",[a._v("索引大大减少了服务器需要扫描的数据量")]),a._v(" "),_("li",[a._v("索引可以帮助服务器避免排序和临时表")]),a._v(" "),_("li",[a._v("索引可以将随机 IO 变为顺序 IO")])]),a._v(" "),_("p",[a._v("但索引不是唯一或有效的优化工具。非常小的表全表扫描可能更快 ; 非常大的表索引性能可能会下降，解决需要分表 ; "),_("em",[_("strong",[a._v("表的数量特别多，可以建立一个元数据信息表，用来查询需要用到的某些特性。")])])]),a._v(" "),_("h3",{attrs:{id:"_5-3-高性能索引的策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-高性能索引的策略","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3 高性能索引的策略")]),a._v(" "),_("h4",{attrs:{id:"_5-3-1-独立的列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-1-独立的列","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.1 独立的列")]),a._v(" "),_("p",[a._v("当索引使用不当，将不能发挥作用 :")]),a._v(" "),_("ul",[_("li",[a._v("作为了表达式的一部分 ( "),_("code",[a._v("WHERE user_id - 1 = 0")]),a._v(" )")]),a._v(" "),_("li",[a._v("作为函数的参数 ( "),_("code",[a._v("WHERE TO_DAYS(created_at) / 365 = 2018")]),a._v(" )")])]),a._v(" "),_("h4",{attrs:{id:"_5-3-2-前缀索引和索引选择性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-2-前缀索引和索引选择性","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.2 前缀索引和索引选择性")]),a._v(" "),_("p",[a._v("有时候需要索引很长的字符列，这会让索引变得大且慢。一个做法是前面提到过的模拟哈希索引。另一种做法是使用前缀索引索引开始的部分字符，这样可以大大节约索引空间从而提高索引的效率。但同时也会降低索引的选择性，即增高了不重复的索引值占总数据量的比例。所以前缀索引需要选择一个合适的长度，权衡某个长度的选择性最接近于完整列长度的选择性即可。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-3-多列索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-3-多列索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.3 多列索引")]),a._v(" "),_("p",[a._v("多列索引有常见的使用错误，如为每个列创建独立的索引，或者不是最优的多列创建顺序。针对同时使用多个列的独立索引，MySQL 有『 索引合并 』的策略，可以通过 EXPLAIN 的 Extra 中 "),_("code",[a._v("Using union()")]),a._v(" 确认，但其实更多时候说明了索引建得很糟糕。也可以通过参数 "),_("code",[a._v("optimizer_switch")]),a._v(" 来关闭索引合并功能。也可以使用 IGNORE INDEX 提示让优化器忽略掉某些索引。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-4-选择合适的索引顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-4-选择合适的索引顺序","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.4 选择合适的索引顺序")]),a._v(" "),_("p",[a._v("多列索引的建立顺序，一个经验法则是将 选择性最高 ( 全局基数最小 ) 的列放到索引最前列，但按深层次来说不如 "),_("em",[_("strong",[a._v("避免随机 IO 和排序")])]),a._v(" 那么重要。应用的设计也应当注意，数值的基数也应该尽可能地小，否则索引形同虚设。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-5-聚簇索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-5-聚簇索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.5 聚簇索引")]),a._v(" "),_("p",[a._v("聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时吧数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-6-覆盖索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-6-覆盖索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.6 覆盖索引")]),a._v(" "),_("p",[a._v("覆盖索引是非常有用的工具，适当情况下可以使用索引来直接获取列的数据而无须回表，从而极大地提高性能。而根据这个特性，很显然像哈希索引、空间索引和全文索引并不能为覆盖索引而用。只有在查询中选择的列包含在索引中才能完全发挥覆盖索引，而针对选择的列不包行索引，在 MySQL 5.6 版本开始改进了 API 实现了“索引条件推送”能尽最大程度使用覆盖索引。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-7-索引扫描排序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-7-索引扫描排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.7 索引扫描排序")]),a._v(" "),_("p",[a._v("MySQL 可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能同时满足这两种任务，这样是最好的。只有当索引的列顺序和 ORDER BY 子句的顺序完全一致，并且所有的排序方向都一样才能使用索引来对结果排序。当对应索引的排序前导列，在 WHERE 或 JOIN 中指定为常量时，也是可以使用索引进行排序的。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-8-压缩-前缀-索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-8-压缩-前缀-索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.8 压缩 ( 前缀 ) 索引")]),a._v(" "),_("p",[a._v("MyISAM 使用前缀压缩来减小索引的大小，从而让更多的索引可以放入内存中。测试表明，对于 CPU 密集型应用，因为扫描需要随机查找，压缩索引使得 MyISAM 在索引查找上要慢好几倍。压缩索引需要在 CPU 内存资源与磁盘之间做权衡。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-9-冗余和重复索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-9-冗余和重复索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.9 冗余和重复索引")]),a._v(" "),_("p",[a._v("重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样的创建重复索引，发现以后应该立即移除 ; 大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。例如，如果在整数列上有一个索引，现在需要额外增加一个很长的 VARCHAR 列来扩展该索引，那性能可能会急剧下降 ( 这关系到系统底层 "),_("em",[_("strong",[a._v("[ ... ]")])]),a._v(" 的处理 ) 。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-10-未使用的索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-10-未使用的索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.10 未使用的索引")]),a._v(" "),_("p",[a._v("除了冗余索引和重复索引，可能还会有一些服务器永远不用的索引，这样的索引完全是累赘，建议考虑删除。使用工具能查到 索引的使用频率 ; 哪些索引是未使用的 。")]),a._v(" "),_("h4",{attrs:{id:"_5-3-11-索引和锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-11-索引和锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.3.11 索引和锁")]),a._v(" "),_("p",[a._v("在高并发场景下 :")]),a._v(" "),_("ul",[_("li",[a._v("在 InnoDB 中按主键插入可能会造成明显的争用。并发插入可能导致间隙锁竞争，另一个是 AUTO_INCREMENT 锁机制。")]),a._v(" "),_("li",[a._v("索引还能帮助锁锁定到必须要的数据行。InnoDB 在二级索引上使用共享 ( 读 ) 锁，但访问主键索引需要排他 ( 写 ) 锁。这消除了使用覆盖索引的可能性，并且使得 SELECT FOR UPDATE 比 LOCK IN SHARE MODE 或非锁定查询要慢很多。")])]),a._v(" "),_("h3",{attrs:{id:"_5-4-索引案例学习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-索引案例学习","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.4 索引案例学习")]),a._v(" "),_("p",[a._v("章节结论 :")]),a._v(" "),_("ul",[_("li",[_("p",[a._v("对于选择性低 ( 比如性别 ) 并且基数小的，但在应用程序需要作多条件过滤，可以在多列索引中用 WHERE IN 来有效使用")])]),a._v(" "),_("li",[_("p",[a._v("多列索引应避免多个列的范围条件 ( 不定数量个等值条件 ) ，如不可避免则应该重新设计")])]),a._v(" "),_("li",[_("p",[a._v("对于排序大量数据，可以针对地增加索引")])]),a._v(" "),_("li",[_("p",[a._v("如果排序不是覆盖索引查询，同时排序结果的分页的偏移量很大，此时光靠索引也无法优化响应时间。这个情况：一可以限制用户浏览的分页的最大数 ; 二可以使用延迟关联先利用覆盖索引再查询结果 ; 三可以添加额外的排序表进行关联")])])]),a._v(" "),_("h3",{attrs:{id:"_5-5-维护索引和表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-维护索引和表","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.5 维护索引和表")]),a._v(" "),_("h4",{attrs:{id:"_5-5-1-找到并修复损坏的表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-1-找到并修复损坏的表","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.5.1 找到并修复损坏的表")]),a._v(" "),_("p",[a._v("如果你遇到了古怪的问题 —— 例如一些不应该发生的错误，可以运行 CHECK TABLE 来检查，通常能找到大多数表和索引的错误。可以使用 REPAIR TABLE 来修复损坏的表，也可以直接 ALTER ( "),_("code",[a._v("ALTER TABLE users ENGINE=INNODB;")]),a._v(" ) 来重建表。")]),a._v(" "),_("h4",{attrs:{id:"_5-5-2-更新索引统计信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-2-更新索引统计信息","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.5.2 更新索引统计信息")]),a._v(" "),_("p",[a._v("MySQL 的查询优化器通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。第一个 API 是 "),_("code",[a._v("records_in_range()")]),a._v(" ，通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录。对于某些存储引擎，该接口返回精确值，例如 MyISAM ; 但对于另一些存储引擎则是一个估算值，例如 InnoDB。第二个 API 是 "),_("code",[a._v("info()")]),a._v(" ，该接口返回各种类型的数据，包括索引的基数 ( 每个键值有多少条记录 ) 。")]),a._v(" "),_("p",[a._v("MySQL 优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。如果表没有统计信息，或者统计信息不准确，优化器就很有可能做出错误的决定。可以通过运行 ANALYZE TABLE 来重新生成统计信息解决这个问题。")]),a._v(" "),_("p",[_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("h4",{attrs:{id:"_5-5-3-减少索引和数据的碎片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-3-减少索引和数据的碎片","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.5.3 减少索引和数据的碎片")]),a._v(" "),_("p",[a._v("B-Tree 索引的碎片化会降低查询效率。根据设计，B-Tree 需要随机磁盘访问才能定位到叶子页。如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就会更好。否则，对于范围查询、索引覆盖扫描等操作来说，速度可能会降低很多倍，索引覆盖扫描更加明显。可以通过执行 OPTIMIZE TABLE 、导出再导入、直接 ALTER 来重建表 的方式来重新整理数据。")]),a._v(" "),_("p",[a._v("数据存储的碎片化比索引更加复杂 : 行碎片、行间碎片、剩余空间碎片。行碎片 ( Row Fragmentation ) 是数据行被存储位多个地方的多个片段中，即使查询只从索引访问一行记录也会受影响。行间碎片 ( Intra-row Fragmentation ) 是逻辑上顺序的页或者行在磁盘上不是顺序存储的，对全表扫描和聚簇索引扫描有影响。剩余空间碎片 ( Free Space Fragmentation ) 是数据页中有大量空余空间，会导致读取浪费。对于 MyISAM 表，这三类碎片化都可能发生。InnoDB 不会出现短小的行碎片，"),_("em",[_("strong",[a._v("但会移动短小的行并重写到一个片段中")])]),a._v(" 。")]),a._v(" "),_("h3",{attrs:{id:"_5-6-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 5.6 总结")]),a._v(" "),_("p",[a._v("大多数情况下都会使用 B-Tree 索引，其他的只适用于特殊目的。三星级索引 : 尽可能地使用数据原生顺序从而避免额外的排序操作 ; 尽可能使用索引覆盖查询 。有时候必须有所取舍以创建最合适的索引，或者寻求替代策略 ( 反范式化、提前计算汇总表 ) 。")]),a._v(" "),_("p",[a._v("建议按响应时间来对查询进行分析，再检查这些查询的 Schema 、SQL 和索引结构，判断是否有查询扫描了太多的行，是否做了很多额外的排序或者使用了临时表，是否使用随机 IO 访问数据，或者是有太多回表查询那些不在索引中的列的操作。")]),a._v(" "),_("h2",{attrs:{id:"第六章：查询性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第六章：查询性能优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 第六章：查询性能优化")]),a._v(" "),_("p",[a._v("高性能 MySQL 需要 查询优化、索引优化、库表结构优化齐头并进，一个不落。")]),a._v(" "),_("h3",{attrs:{id:"_6-1-为什么查询速度会慢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-为什么查询速度会慢","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.1 为什么查询速度会慢")]),a._v(" "),_("p",[a._v("查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。其中『执行』包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。")]),a._v(" "),_("p",[a._v("查询需要在不同的地方花费时间，包括网络，CPU 计算，生成统计信息和执行计划、锁等待（互斥等待）等操作，尤其是向底层存储引擎检索数据的调用操作，这些调用需要在内存操作、CPU 操作和内存不足时导致的 I/O 操作上消耗时间。根据存储引擎不同，可能还会产生大量的上下文切换以及系统调用。")]),a._v(" "),_("h3",{attrs:{id:"_6-2-慢查询基础：优化数据访问"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-慢查询基础：优化数据访问","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2 慢查询基础：优化数据访问")]),a._v(" "),_("p",[a._v("性能低下的最基本原因是访问太多「数据」。")]),a._v(" "),_("h4",{attrs:{id:"_6-2-1-是否向数据库请求了不需要的数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-1-是否向数据库请求了不需要的数据","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2.1 是否向数据库请求了不需要的数据")]),a._v(" "),_("p",[a._v("经典案例：")]),a._v(" "),_("ul",[_("li",[a._v("重复查询相同的数据")]),a._v(" "),_("li",[a._v("结果包含多余的数据行")]),a._v(" "),_("li",[a._v("取出不需要（没有用到）的列")])]),a._v(" "),_("h4",{attrs:{id:"_6-2-2-是否扫描额外的记录"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-是否扫描额外的记录","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2.2 是否扫描额外的记录")]),a._v(" "),_("p",[a._v("最简单的衡量指标：")]),a._v(" "),_("ul",[_("li",[a._v("响应时间")]),a._v(" "),_("li",[a._v("扫描行数")]),a._v(" "),_("li",[a._v("返回行数")])]),a._v(" "),_("h5",{attrs:{id:"_6-2-2-1-响应时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-1-响应时间","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2.2.1 响应时间")]),a._v(" "),_("p",[a._v("服务时间和排队时间为响应时间。服务时间是指真正处理数据的时间，排队时间是指等待「资源」的时间 —— 等待 I/O 操作、行表锁、高并发资源竞争等等。估算查询的响应时间：了解需要哪些索引以及执行计划，然后计算顺序和随机 I/O ，再乘以具体硬件条件下一次 I/O 的时间。")]),a._v(" "),_("h5",{attrs:{id:"_6-2-2-2-扫描行数和返回行数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-2-扫描行数和返回行数","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2.2.2 扫描行数和返回行数")]),a._v(" "),_("p",[a._v("由于行的长短、内存表访问的关系，行数不能真实有效代表响应时间。理想情况下扫描行数相等于返回行数，关联查询时扫描行数会比返回行数更多。")]),a._v(" "),_("h5",{attrs:{id:"_6-2-2-3-扫描行数和访问类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-2-3-扫描行数和访问类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.2.2.3 扫描行数和访问类型")]),a._v(" "),_("p",[a._v("评估查询开销需要考虑从表中找到某一行数据的成本。访问方式可能是：查找并返回一行结果；需要扫描很多行返回一行结果；无须扫描就能返回结果 。EXPLAIN 中 type 列反应了访问类型，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大。不需要记住这些访问类型，但需要明白扫描表、扫描索引、范围访问和单值访问的概念。没有办法找到合适的访问类型最好办法通常就是增加一个合适索引。")]),a._v(" "),_("p",[a._v("优化查询需要扫描大量的数据但只返回少数的行：")]),a._v(" "),_("ul",[_("li",[a._v("使用索引覆盖扫描")]),a._v(" "),_("li",[a._v("改变库表结构：例如使用单独的汇总表")]),a._v(" "),_("li",[a._v("重写查询让优化器能够以更优的方式执行")])]),a._v(" "),_("h3",{attrs:{id:"_6-3-重构查询的方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-重构查询的方式","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.3 重构查询的方式")]),a._v(" "),_("h4",{attrs:{id:"_6-3-1-一个复杂查询还是多个简单查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-1-一个复杂查询还是多个简单查询","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.3.1 一个复杂查询还是多个简单查询")]),a._v(" "),_("p",[a._v("一个复杂查询还是多个简单查询需要实际衡量，复杂的查询维护难度大，耗时有可能比多个简单查询多。真正避免的是，由于不严谨的设计，原本可以由一次高效的查询完成，却分成多次「简单」的查询。")]),a._v(" "),_("h4",{attrs:{id:"_6-3-2-切分大的查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-2-切分大的查询","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.3.2 切分大的查询")]),a._v(" "),_("p",[a._v("有时候对于一个大查询我们需要「分而治之」，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。切分大的查询有助于分散压力，提高并发。")]),a._v(" "),_("h4",{attrs:{id:"_6-3-3-分解关联查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-3-分解关联查询","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.3.3 分解关联查询")]),a._v(" "),_("div",{staticClass:"language-sql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sql"}},[_("code",[_("span",{attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" "),_("span",{attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),_("span",{attrs:{class:"token keyword"}},[a._v("FROM")]),a._v(" tag\n\t"),_("span",{attrs:{class:"token keyword"}},[a._v("JOIN")]),a._v(" tag_post "),_("span",{attrs:{class:"token keyword"}},[a._v("ON")]),a._v(" tag_post"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("tag_id "),_("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" tag"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("id\n\t"),_("span",{attrs:{class:"token keyword"}},[a._v("JOIN")]),a._v(" post "),_("span",{attrs:{class:"token keyword"}},[a._v("ON")]),a._v(" tag_post"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("post_id "),_("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" post"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("id\n"),_("span",{attrs:{class:"token keyword"}},[a._v("WHERE")]),a._v(" tag"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("tag"),_("span",{attrs:{class:"token operator"}},[a._v("=")]),_("span",{attrs:{class:"token string"}},[a._v("'mysql'")]),_("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),_("span",{attrs:{class:"token comment"}},[a._v("-- 分解")]),a._v("\n\n"),_("span",{attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" "),_("span",{attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),_("span",{attrs:{class:"token keyword"}},[a._v("FROM")]),a._v(" tag_post "),_("span",{attrs:{class:"token keyword"}},[a._v("WHERE")]),a._v(" tag_id "),_("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{attrs:{class:"token number"}},[a._v("111")]),_("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" "),_("span",{attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),_("span",{attrs:{class:"token keyword"}},[a._v("FROM")]),a._v(" tag_post "),_("span",{attrs:{class:"token keyword"}},[a._v("WHERE")]),a._v(" tag_id "),_("span",{attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{attrs:{class:"token number"}},[a._v("222")]),_("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{attrs:{class:"token keyword"}},[a._v("SELECT")]),a._v(" "),_("span",{attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),_("span",{attrs:{class:"token keyword"}},[a._v("FROM")]),a._v(" post "),_("span",{attrs:{class:"token keyword"}},[a._v("WHERE")]),a._v(" post"),_("span",{attrs:{class:"token punctuation"}},[a._v(".")]),a._v("d "),_("span",{attrs:{class:"token operator"}},[a._v("IN")]),a._v(" "),_("span",{attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{attrs:{class:"token number"}},[a._v("12")]),_("span",{attrs:{class:"token punctuation"}},[a._v(",")]),_("span",{attrs:{class:"token number"}},[a._v("34")]),_("span",{attrs:{class:"token punctuation"}},[a._v(",")]),_("span",{attrs:{class:"token number"}},[a._v("56")]),_("span",{attrs:{class:"token punctuation"}},[a._v(",")]),_("span",{attrs:{class:"token number"}},[a._v("78")]),_("span",{attrs:{class:"token punctuation"}},[a._v(")")]),_("span",{attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),_("ul",[_("li",[a._v("缓存的效率更高，「细致地」缓存单调查询")]),a._v(" "),_("li",[a._v("减少行表锁的时间")]),a._v(" "),_("li",[a._v("在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展")]),a._v(" "),_("li",[a._v("查询本身效率也可能会有所提升，使用 "),_("code",[a._v("IN()")]),a._v(" 代替关联查询从而按照 ID 顺序进行查询可能比随机的关联高效")]),a._v(" "),_("li",[a._v("可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。从这点看，这样的重构还可能会减少网络和内存的消耗。")]),a._v(" "),_("li",[a._v("更进一步，这样做相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联。某些场景哈希关联的效率要高很多。")])]),a._v(" "),_("h3",{attrs:{id:"_6-4-查询执行的基础"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-查询执行的基础","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4 查询执行的基础")]),a._v(" "),_("p",[a._v("当希望 MySQL 能够以更高的性能运行查询时，最好的办法就是弄清楚 MySQL 是如何优化和执行查询的。很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理的方式运行。")]),a._v(" "),_("p",[a._v("MySQL 执行一个查询的过程：")]),a._v(" "),_("ol",[_("li",[a._v("客户端发送一条查询给服务器。")]),a._v(" "),_("li",[a._v("服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果 ; 否则进入下一阶段。")]),a._v(" "),_("li",[a._v("服务器端进行 SQL 解析、预处理、再又优化器生成对应的执行计划。")]),a._v(" "),_("li",[a._v("MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。")]),a._v(" "),_("li",[a._v("将结果返回给客户端。")])]),a._v(" "),_("h4",{attrs:{id:"_6-4-1-客户端-服务器-通信协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-1-客户端-服务器-通信协议","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.1 客户端 / 服务器 通信协议")]),a._v(" "),_("p",[a._v("MySQL 客户端和服务器之间的通信协议是「半双工」的，即不能双方同时互发数据。流量没法进行控制，一旦一端开始发送数据，另一端要接收完整的数据才能响应它。客户端用一个单独的数据包（ packet ）将查询传给服务器，服务器参数 "),_("code",[a._v("max_allowed_packet")]),a._v(" 可以控制。")]),a._v(" "),_("p",[a._v("服务器执行查询后发送数据到客户端，默认是获得全部结果集并缓存到内存里一次性发送，还可以逐行获取。所有的数据都发送到客户端后服务器才能释放一个请求的资源，因此接收全部结果集并缓存通常可以减少服务器压力，能尽早结束释放服务资源。")]),a._v(" "),_("p",[a._v("PHP 中 "),_("code",[a._v("mysql_query()")]),a._v(" 将查询所有结果缓存到本地； "),_("code",[a._v("mysql_unbuffered_query()")]),a._v(" 将查询所有结果集留在服务器。")]),a._v(" "),_("h5",{attrs:{id:"_6-4-1-1-查询状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-1-1-查询状态","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.1.1 查询状态")]),a._v(" "),_("p",[a._v("使用以下命令可以得到 MySQL 连接的线程状态：")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("mysql> SHOW FULL PROCESSLIST;\n")])])]),_("p",[a._v("Command 列：")]),a._v(" "),_("ul",[_("li",[a._v("Sleep ：等待客户端发送新请求")]),a._v(" "),_("li",[a._v("Query ：执行查询 或 讲结果发送给客户端")]),a._v(" "),_("li",[a._v("Locked ：在 MySQL 服务层等待表锁")]),a._v(" "),_("li",[a._v("statistics ：计算统计信息生成执行计划")]),a._v(" "),_("li",[a._v("copying to tmp table [ on disk ] ：线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做 GROUP BY 操作，要么是文件排序操作，或者是 UNION 操作。如果这个状态后面还有「 on disk」标记，那表示MySQL正在将一个内存临时表放到磁盘上。")]),a._v(" "),_("li",[a._v("Sorting result ：对结果集排序")]),a._v(" "),_("li",[a._v("Sending data ：读取和处理 SELECT 语句的行，并将数据发送到客户端。由于在此状态期间发生的操作往往会执行大量磁盘访问（读取），因此它通常是给定查询生命周期中运行时间最长的状态。")])]),a._v(" "),_("h4",{attrs:{id:"_6-4-2-查询缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-2-查询缓存","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.2 查询缓存")]),a._v(" "),_("p",[a._v("在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。查询和缓存中的查询即使只有一个字符不同，那也不会匹配缓存结果，这种情况下查询就会进入下一阶段的处理。")]),a._v(" "),_("h4",{attrs:{id:"_6-4-3-查询优化处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-查询优化处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3 查询优化处理")]),a._v(" "),_("p",[a._v("查询的生命周期的下一步是将一个 SQL 转换成一个执行计划，MySQL 再依照这个执行计划和存储引擎进行交互。含多个阶段：解析 SQL 、预处理、优化 SQL 执行计划。")]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-1-语法解析器-和-预处理器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-1-语法解析器-和-预处理器","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.1 语法解析器 和 预处理器")]),a._v(" "),_("p",[a._v("使用 MySQL 语法规则验证和解析查询并生成「解析树」，然后由预处理器进一步检查是否合法（例如检查数据表和列是否存在等），验证权限。")]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-2-查询优化器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-2-查询优化器","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.2 查询优化器")]),a._v(" "),_("p",[a._v("查询优化器将语法树转化为执行计划。一条查询可以有很多种执行方式，查询优化器就是寻找最好的执行计划。它将预测执行计划的成本，通常是计算随机读取数据页的成本，也有更复杂的操作估算（例如 WHERE 条件比较的成本）。")]),a._v(" "),_("p",[a._v("可以通过以下命令获得上一条查询的成本：")]),a._v(" "),_("div",{staticClass:"language-m y sm y extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("mysql> SHOW STATUS LIKE 'Last_query_cost';\n")])])]),_("p",[a._v("这个结果表示 MySQL 的优化器认为大概需要多少个数据页的随机查找才能完成上面的查询。这是根据一系列的统计信息计算得来的：每个表或者索引的页面个数、索引的基数（索引中不同值的数量）、索引和数据行的长度、索引分布情况。优化器在评估成本的时候并不考虑任何层面的缓存，它假设读取任何数据都需要一次磁盘 I/O 。")]),a._v(" "),_("p",[a._v("有很多种原因会导致 MySQL 优化器错误地选择执行计划：")]),a._v(" "),_("ul",[_("li",[a._v("统计信息不准确，依赖于存储引擎")]),a._v(" "),_("li",[a._v("执行计划的成本估算不等同于实际执行的成本，数据页可能在内存中或者是顺序页面")]),a._v(" "),_("li",[a._v("最优执行计划可能不是你想象中的那个时间最短的计划，而是成本最低")]),a._v(" "),_("li",[a._v("不会考虑并发")]),a._v(" "),_("li",[a._v("有时也会基于一些固定规则选择而不是成本")]),a._v(" "),_("li",[a._v("无法估算所有计划时（例如太多表的关联顺序）可能会错过最优的")])]),a._v(" "),_("p",[a._v("优化策略可以简单地分为两种，一种是静态优化，一种是动态优化。")]),a._v(" "),_("p",[a._v("静态优化 直接对解析树进行分析，并完成优化。例如，优化器可以通过一些简单的代数变换将 WHERE 条件转换成另一种等价形式。静态优化不依赖于特别的数值，如 WHERE 条件中带入的一些常数等。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化。可以认为这是一种「编译时优化」。")]),a._v(" "),_("p",[a._v("动态优化 和查询的上下文有关，也可能和很多其他因素有关，例如 WHERE 条件中的取值、索引中条目对应的数据行数等。这需要在每次查询的时候（甚至执行过程中）都重新评估，可以认为这是「运行时优化」。")]),a._v(" "),_("p",[a._v("下面是一些 MySQL 能够处理的优化类型：")]),a._v(" "),_("ul",[_("li",[a._v("重新定义关联表的顺序：优先对整体选择性高的表")]),a._v(" "),_("li",[a._v("将外连接（ LEFT / RIGHT OUTER JOIN ）转化为内连接（ INNER JOIN ）：根据 WHERE 条件、库表结构 等等")]),a._v(" "),_("li",[a._v("使用等价变换规则：优化表达式")]),a._v(" "),_("li",[a._v("优化 COUNT() 、MIN() 、MAX() ：利用 B-Tree 特点来计算、直接引用计数器")]),a._v(" "),_("li",[a._v("预估并转化为常数表达式（和等值传播类似？）：根据先前执行计划步骤中的常数，为后续转化")]),a._v(" "),_("li",[a._v("覆盖索引扫描：查询的列在索引中包含就无需回表查询")]),a._v(" "),_("li",[a._v("子查询优化：")]),a._v(" "),_("li",[a._v("提前终止查询：LIMIT 子句、不可能成立的条件、"),_("s",[a._v("局部数据跳过")]),a._v(" 等等")]),a._v(" "),_("li",[a._v("等值传播（和预估并转化为常数表达式类似？）：扩大相等字段的条件应用范围")]),a._v(" "),_("li",[a._v("列表 IN() 、多个 OR 条件 的比较：利用二分查找有序列表优化处理速度")])]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-3-数据和索引的统计信息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-3-数据和索引的统计信息","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.3 数据和索引的统计信息")]),a._v(" "),_("p",[a._v("优化器需要数据和索引的统计信息来选择最优执行计划。但优化器在 MySQL 服务层，而统计信息来自于存储引擎，所以存储引擎的不同可能会影响优化器。")]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-4-mysql-如何执行关联查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-4-mysql-如何执行关联查询","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.4 MySQL 如何执行关联查询")]),a._v(" "),_("p",[a._v("MySQL 中「关联」一词所包含的意义比一般意义上理解的要更广泛，不仅仅是一个查询需要到两个表匹配才叫关联。每一个查询、片段（包括子查询，甚至基于单表的 SELECT ）都可能是关联。从本质上说，MySQL 对所有的类型的查询都以同样的方式运行，对任何关联都执行嵌套循环关联操作。")]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-5-执行计划"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-5-执行计划","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.5 执行计划")]),a._v(" "),_("p",[a._v("MySQL 生成查询的一棵指令（左侧深度优先）树，然后通过存储引擎执行返回结果。最终的执行计划包含了重构查询的全部信息。如果对某个查询执行 EXPLAIN EXTENDED 后再执行 SHOW WARNINGS 就可以看到重构出的查询。")]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-6-关联查询优化器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-6-关联查询优化器","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.6 关联查询优化器")]),a._v(" "),_("h5",{attrs:{id:"_6-4-3-7-排序优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-3-7-排序优化","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.3.7 排序优化")]),a._v(" "),_("p",[a._v("排序无论如何都是一个成本很高的操作，尽可能避免排序或大量数据的排序。如果不能利用索引排序，则需要用到文件排序 ( filesort ) ，把数据放在内存中进行排序。如果数据太多，则对数据分块排序放置在磁盘上 ( 进行桶排序 "),_("em",[_("strong",[a._v("[ ... ]")])]),a._v(" ) ，最后合并返回。")]),a._v(" "),_("p",[a._v("在关联查询的时候如果需要排序，如果 ORDER BY 都来自于 第一个关联的表，那么在关联处理第一个表时就进行文件排序，这种情况 EXPLAIN 结果的 Extra 列可以看到 “Using filesort”。否则，会将关联结果放到临时表中，在所有关联结束后在进行文件排序，这种情况 EXPLAIN 结果的 Extra 列可以看到 “Using temporary; Using filesort”。另外即使有 LIMIT 也需要等到排序完之后才能应用，不过 MySQL 5.6 版本做了改进，根据实际情况选择抛弃不满足条件的结果再进行排序。")]),a._v(" "),_("h4",{attrs:{id:"_6-4-4-查询执行引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-4-查询执行引擎","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.4 查询执行引擎")]),a._v(" "),_("h4",{attrs:{id:"_6-4-5-返回结果给客户端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-5-返回结果给客户端","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.4.5 返回结果给客户端")]),a._v(" "),_("h3",{attrs:{id:"_6-5-查询优化器的局限性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-查询优化器的局限性","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.5 查询优化器的局限性")]),a._v(" "),_("p",[a._v("查询优化器很多时候会以不是你想象中的计划那样执行查询语句，重要的思想是要自己分析查询语句和查询结果是否符合你的想象。查询语句往往不只有一种写法来实现，最好可以通过性能测试可能的查询语句，选择性能最好的。 "),_("em",[a._v("[ 书中这里两小节阐述了关联自查询的问题，因为时空和技巧关系，只好这样总结 ]")])]),a._v(" "),_("p",[a._v("以下是一些优化经验：")]),a._v(" "),_("ul",[_("li",[a._v("如果 UNION 需要限制获取记录数，一般需要在各个局部和全局都加上 相同的 LIMIT 条件。")]),a._v(" "),_("li",[a._v("等值传递会带来一些意想不到的额外消耗。例如，有一个非常大的 IN() 列表，而优化器发现存在 WHERE 、 ON 或者 USING 子句，将这个列表的值和另外一个表的相关列关联。如果这个列表非常大，会导致优化和执行都变慢。 "),_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("li",[a._v("MySQL 无法利用多核特性来并行执行查询，所以并没有什么方式可以并行执行。")]),a._v(" "),_("li",[a._v("MySQL 并不支持哈希关联，所有关联都是嵌套循环关联。不过有技巧可以通过哈希索引曲线实现哈希关联，另外值得一提 MariaDB 已经实现了真正的哈希关联。")]),a._v(" "),_("li",[a._v("MySQL 不能很好的支持松散 ( 多列 ) 索引扫描，一个简单的绕过问题的办法就是给前导列加上常数值。")]),a._v(" "),_("li",[a._v("MIN() 、MAX() 或许可以用 ORDER BY 或 LIMIT 1 来取代，因为当它们没有索引会全表扫描。")]),a._v(" "),_("li",[a._v("MySQL 不允许对同一张表同时进行查询和更新，为绕过这个限制，可以使用临时表。即书中更新不能从 FROM 子查询中获取数据，但可以通过 JOIN 隐式生成的临时表来获取数据更新。")])]),a._v(" "),_("p",[a._v("以下是一些查询优化器的提示 ( hint )：")]),a._v(" "),_("ul",[_("li",[a._v("HIGH_PRIORITY & LOW_PRIORITY ：查询语句优先级")]),a._v(" "),_("li",[a._v("DELAYED ：服务端缓冲写入数据并立刻响应客户端")]),a._v(" "),_("li",[a._v("STRAIGHT_JOIN ：优化器按照语句的关联顺序")]),a._v(" "),_("li",[a._v("SQL_SMALL_RESULT & SQL_BIG_RESULT ：按数据量选择内存或磁盘")]),a._v(" "),_("li",[a._v("SQL_BUFFER_RESULT ：临时存放结果以尽快释放表锁")]),a._v(" "),_("li",[a._v("SQL_CACHE & SQL_NO_CACHE ：结果集是否可缓存")]),a._v(" "),_("li",[a._v("SQL_CALC_FOUND_ROWS ：(假提示) 返回结果集包含更多信息")]),a._v(" "),_("li",[a._v("FOR UPDATE & LOCK IN SHARE MODE ： (假提示) 排他锁和共享锁")]),a._v(" "),_("li",[a._v("USE INDEX \\ IGNORE INDEX \\ FORCE INDEX ：索引的使用")]),a._v(" "),_("li",[a._v("optimizer_search_depth ：优化器穷举执行计划限度 ( 优化过多 “Statistics”状态的线程 )")]),a._v(" "),_("li",[a._v("optimizer_prune_level ： "),_("em",[_("strong",[a._v("[ ... ]")])])]),a._v(" "),_("li",[a._v("optimizer_switch ： "),_("em",[_("strong",[a._v("[ ... ]")])])])]),a._v(" "),_("h3",{attrs:{id:"_6-6-查询优化器的提示-hint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-查询优化器的提示-hint","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.6 查询优化器的提示 ( hint )")]),a._v(" "),_("h3",{attrs:{id:"_6-7-优化特定类型的查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-优化特定类型的查询","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.7 优化特定类型的查询")]),a._v(" "),_("p",[a._v("表中特定项目的统计方法：")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("mysql> select sum(if(active = 1,1,0)) as active, sum(if(active = 0,1,0)) as inactive from sakila.customer;\nmysql> select count(active = 1 or null) as active, count(active = 0 or null) as inactive from sakila.customer;\n")])])]),_("p",[a._v("有些时候业务场景不要求完全精确的 COUNT 值，那可以用 EXPLAIN 的优化器估算值来代替。")]),a._v(" "),_("p",[a._v("优化关联查询的要点：")]),a._v(" "),_("ul",[_("li",[a._v("确保 ON 或者 USING 子句中的列上有索引。当表 A 和表 B 用 c 列关联，如果优化器的关联顺序是 B > A ，那么就不需要再 B 表的对应列上建立索引。")]),a._v(" "),_("li",[a._v("确保 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列，才能使用索引来优化这个过程。")])]),a._v(" "),_("p",[a._v("优化排序查询的要点：")]),a._v(" "),_("ul",[_("li",[a._v("使用单调递增索引")]),a._v(" "),_("li",[a._v("使用覆盖索引来延迟关联")]),a._v(" "),_("li",[a._v("使用数据自身的预算边界值")]),a._v(" "),_("li",[a._v("从用户设计上拒绝大页码的查询")])]),a._v(" "),_("h3",{attrs:{id:"_6-8-案例学习"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-8-案例学习","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.8 案例学习")]),a._v(" "),_("h3",{attrs:{id:"_6-9-总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-9-总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 6.9 总结")])])}],!1,null,null,null);r.options.__file="Notes-of-High-Performance-MySQL.md";t.default=r.exports}}]);